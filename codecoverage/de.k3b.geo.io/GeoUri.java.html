<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="de"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>GeoUri.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">k3b-geoHelper</a> &gt; <a href="index.source.html" class="el_package">de.k3b.geo.io</a> &gt; <span class="el_source">GeoUri.java</span></div><h1>GeoUri.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2015-2016 by k3b.
 *
 * This file is part of k3b-geoHelper library.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.k3b.geo.io;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import de.k3b.geo.api.GeoPointDto;
import de.k3b.geo.api.IGeoPointInfo;
import de.k3b.util.IsoDateTimeParser;

/**
 * Converts between a {@link de.k3b.geo.api.IGeoPointInfo} and a uri string.&lt;br/&gt;
 * Format:&lt;br/&gt;
 * geo:{lat}{,lon{,hight_ignore}}}{?q={lat}{,lon}{,hight_ignore}{(name)}}{&amp;uri=uri}{&amp;id=id}{&amp;d=description}{&amp;z=zmin{&amp;z2=zmax}}{&amp;t=timeOfMeasurement}
 * Example (with {@link de.k3b.geo.io.GeoUri#OPT_FORMAT_REDUNDANT_LAT_LON} set):&lt;br/&gt;
 * geo:12.345,-56.7890123?q=12.345,-56.7890123(name)&amp;z=5&amp;z2=7&amp;uri=uri&amp;d=description&amp;id=id&amp;t=1991-03-03T04:05:06Z
 * &lt;p/&gt;
 * This should be compatible with standard http://tools.ietf.org/html/draft-mayrhofer-geo-uri-00
 * and with googlemap for android. This implementation has aditional non-standard parameters
 * for LocationViewer clients.&lt;br/&gt;
 * &lt;br/&gt;
 * Created by k3b on 13.01.2015.
 */
public class GeoUri {
    /* constants that define behaviour of fromUri and toUri */

    public static final int OPT_DEFAULT = 0;
    /** In toUriString: If set lat/lon is inserted twice: in q= parameter and in geo. &lt;br/&gt;
     * If not lat/lon is only in geo part but not in the q= part*/
    public static final int OPT_FORMAT_REDUNDANT_LAT_LON = 1;
    /** In fromUri: if set tries to get time, location, name for everywhere.&lt;br/&gt;
     * Example: &quot;geo:?d=I was in (Hamburg) located at 53,10 on 1991-03-03T04:05:06Z&quot; would set
     * name, location and time from the description text.
     */
    public static final int OPT_PARSE_INFER_MISSING = 0x100;

    /**
     * Default for url-encoding.
     */
    private static final String DEFAULT_ENCODING = &quot;UTF-8&quot;;
    public static final String GEO_SCHEME = &quot;geo:&quot;;
    public static final String AREA_SCHEME = &quot;geoarea:&quot;;

    /* regular expressions used by the parser.&lt;br/&gt;
       '(?:&quot;+something+&quot;)&quot;' is a non capturing group; &quot;\s&quot; white space */
    private final static String regexpName = &quot;(?:\\s*\\(([^\\(\\)]+)\\))&quot;; // i.e. &quot; (hallo world)&quot;
<span class="fc" id="L72">    private final static Pattern patternName = Pattern.compile(regexpName);</span>
    private final static String regexpDouble = &quot;([+\\-]?[0-9\\.]+)&quot;; // i.e. &quot;-123.456&quot;
    private final static String regexpDoubleOptional = regexpDouble + &quot;?&quot;;
    private final static String regexpCommaDouble = &quot;(?:\\s*,\\s*&quot; + regexpDouble + &quot;)&quot;; // i.e. &quot; , +123.456&quot;
    private final static String regexpCommaDoubleOptional = regexpCommaDouble + &quot;?&quot;;
    private final static String regexpLatLonAlt = regexpDouble + regexpCommaDouble + regexpCommaDoubleOptional;
    private final static String regexpLatLonLatLon = regexpDouble + regexpCommaDouble + regexpCommaDouble + regexpCommaDouble;
<span class="fc" id="L79">    private final static Pattern patternLatLonAlt = Pattern.compile(regexpLatLonAlt);</span>
<span class="fc" id="L80">    private final static Pattern patternLatLonLatLon = Pattern.compile(regexpLatLonLatLon);</span>
<span class="fc" id="L81">    private final static Pattern patternTime = Pattern.compile(&quot;([12]\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\dZ)&quot;);</span>

    private final static String regexpHref = &quot;(?:\\s*href\\s?\\=\\s?['\&quot;]([^'\&quot;]*)['\&quot;])&quot;; // i.e. href='hallo'
<span class="fc" id="L84">    private final static Pattern patternHref = Pattern.compile(regexpHref);</span>

    private final static String regexpSrc = &quot;(?:\\s*src\\s?\\=\\s?['\&quot;]([^'\&quot;]*)['\&quot;])&quot;; // i.e. src='hallo'
<span class="fc" id="L87">    private final static Pattern patternSrc = Pattern.compile(regexpSrc);</span>

    /* current state */

    /** formating/parsing options */
    private final int options;

    /** for uri-formatter: next delimiter for a parameter. can be &quot;?&quot; or &quot;&amp;&quot;  */
    private String delim;

    /** create wit options from OPT_xxx */
<span class="fc" id="L98">    public GeoUri(int options) {</span>
<span class="fc" id="L99">        this.options = options;</span>
<span class="fc" id="L100">    }</span>

    /** load IGeopoint from uri-string */
    public IGeoPointInfo fromUri(String uri) {
<span class="fc" id="L104">        return fromUri(uri, new GeoPointDto());</span>
    }

    /** load IGeopoint from uri-string into parseResult. */
    public &lt;TGeo extends GeoPointDto&gt;  TGeo fromUri(String uri, TGeo parseResult) {
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (uri == null) return null;</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        if (!uri.startsWith(GEO_SCHEME)) return null;</span>

<span class="fc" id="L112">        int queryOffset = uri.indexOf(&quot;?&quot;);</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (queryOffset &gt;= 0) {</span>
<span class="fc" id="L115">            String query = uri.substring(queryOffset+1);</span>
<span class="fc" id="L116">            uri = uri.substring(0, queryOffset);</span>
<span class="fc" id="L117">            HashMap&lt;String, String&gt; parmLookup = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L118">            String[] params = query.split(&quot;&amp;&quot;);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            for (String param : params) {</span>
<span class="fc" id="L120">                parseAddQueryParamToMap(parmLookup, param);</span>
            }
<span class="fc" id="L122">            parseResult.setDescription(parmLookup.get(GeoUriDef.DESCRIPTION));</span>
<span class="fc" id="L123">            parseResult.setLink(parmLookup.get(GeoUriDef.LINK));</span>
<span class="fc" id="L124">            parseResult.setSymbol(parmLookup.get(GeoUriDef.SYMBOL));</span>
<span class="fc" id="L125">            parseResult.setId(parmLookup.get(GeoUriDef.ID));</span>
<span class="fc" id="L126">            parseResult.setZoomMin(GeoFormatter.parseZoom(parmLookup.get(GeoUriDef.ZOOM)));</span>
<span class="fc" id="L127">            parseResult.setZoomMax(GeoFormatter.parseZoom(parmLookup.get(GeoUriDef.ZOOM_MAX)));</span>
            // parameters from standard value and/or infered
<span class="fc" id="L129">            ArrayList&lt;String&gt; whereToSearch = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L130">            whereToSearch.add(parmLookup.get(GeoUriDef.QUERY)); // lat lon from q have precedence over url-path</span>
<span class="fc" id="L131">            whereToSearch.add(uri);</span>
<span class="fc" id="L132">            whereToSearch.add(parmLookup.get(GeoUriDef.LAT_LON));</span>

<span class="fc" id="L134">            final boolean inferMissing = isSet(GeoUri.OPT_PARSE_INFER_MISSING);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (inferMissing) {</span>
<span class="fc" id="L136">                whereToSearch.add(parseResult.getDescription());</span>
<span class="fc" id="L137">                whereToSearch.addAll(parmLookup.values());</span>
            }

<span class="fc" id="L140">            parseResult.setName(parseFindFromPattern(patternName, parseResult.getName(), whereToSearch));</span>
<span class="fc" id="L141">            parseResult.setTimeOfMeasurement(parseTimeFromPattern(parseResult.getTimeOfMeasurement(), parmLookup.get(GeoUriDef.TIME), whereToSearch));</span>

<span class="fc" id="L143">            parseLatOrLon(parseResult, whereToSearch);</span>

<span class="fc bfc" id="L145" title="All 2 branches covered.">            if (parseResult.getName() == null) {</span>
<span class="fc" id="L146">                parseResult.setName(parmLookup.get(GeoUriDef.NAME));</span>
            }
<span class="fc bfc" id="L148" title="All 2 branches covered.">            if (inferMissing) {</span>
<span class="fc" id="L149">                parseResult.setLink(parseFindFromPattern(patternHref, parseResult.getLink(), whereToSearch));</span>
<span class="fc" id="L150">                parseResult.setSymbol(parseFindFromPattern(patternSrc, parseResult.getSymbol(), whereToSearch));</span>
            }
<span class="fc" id="L152">        } else {</span>
            // no query parameter
<span class="fc" id="L154">            ArrayList&lt;String&gt; whereToSearch = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L155">            whereToSearch.add(uri);</span>
<span class="fc" id="L156">            parseLatOrLon(parseResult, whereToSearch);</span>
        }
<span class="fc" id="L158">        return parseResult;</span>
    }

    /** load IGeopoint from uri-string into parseResult. */
    public &lt;TGeo extends GeoPointDto&gt;  TGeo[] fromUri(String uri, TGeo[] parseResult) {
<span class="pc bpc" id="L163" title="3 of 6 branches missed.">        if ((uri == null) || (parseResult == null) || (parseResult.length &lt; 2)) return null;</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (!uri.startsWith(AREA_SCHEME)) return null;</span>

<span class="fc" id="L166">        Matcher m = parseFindWithPattern(patternLatLonLatLon, uri);</span>

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (m != null) {</span>
<span class="fc" id="L169">            int nextCoord = 1;</span>
            try {
<span class="fc" id="L171">                parseResult[0].setLatitude(GeoFormatter.parseLatOrLon(m.group(nextCoord++))).setLongitude(GeoFormatter.parseLatOrLon(m.group(nextCoord++)));</span>
<span class="fc" id="L172">                parseResult[1].setLatitude(GeoFormatter.parseLatOrLon(m.group(nextCoord++))).setLongitude(GeoFormatter.parseLatOrLon(m.group(nextCoord++)));</span>
<span class="fc" id="L173">                return parseResult;</span>
<span class="nc" id="L174">            } catch (ParseException e) {</span>
<span class="nc" id="L175">                e.printStackTrace();</span>
            }
        }
<span class="nc" id="L178">        return null;</span>
    }

    /** infer name,time,link,symbol from textToBeAnalysed if not already set. */
    public static GeoPointDto inferMissing(GeoPointDto parseResult, String textToBeAnalysed) {

<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (textToBeAnalysed != null) {</span>
<span class="fc" id="L185">            ArrayList&lt;String&gt; whereToSearch = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L186">            whereToSearch.add(textToBeAnalysed);</span>

<span class="fc" id="L188">            parseResult.setName(parseFindFromPattern(patternName, parseResult.getName(), whereToSearch));</span>
<span class="fc" id="L189">            parseResult.setTimeOfMeasurement(parseTimeFromPattern(parseResult.getTimeOfMeasurement(), null, whereToSearch));</span>
<span class="fc" id="L190">            parseResult.setLink(parseFindFromPattern(patternHref, parseResult.getLink(), whereToSearch));</span>
<span class="fc" id="L191">            parseResult.setSymbol(parseFindFromPattern(patternSrc, parseResult.getSymbol(), whereToSearch));</span>
        }
<span class="fc" id="L193">        return parseResult;</span>
    }

    private static ArrayList&lt;String&gt; toStringArray(String[] whereToSearch) {
<span class="fc" id="L197">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        for (String candidate : whereToSearch) {</span>
<span class="fc" id="L199">            arrayList.add(candidate);</span>
        }
<span class="fc" id="L201">        return arrayList;</span>
    }

    /** parsing helper: set first finding of lat and lon to parseResult */
    public static void parseLatOrLon(GeoPointDto parseResult, String... whereToSearch) {
<span class="fc" id="L206">        parseLatOrLon(parseResult, toStringArray(whereToSearch));</span>
<span class="fc" id="L207">    }</span>

    /** parsing helper: set first finding of lat and lon to parseResult */
    private static void parseLatOrLon(GeoPointDto parseResult, ArrayList&lt;String&gt; whereToSearch) {
<span class="fc" id="L211">        Matcher m = parseFindWithPattern(patternLatLonAlt, whereToSearch);</span>

<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (m != null) {</span>
            try {
<span class="fc" id="L215">                final String val = m.group(1);</span>
<span class="fc" id="L216">                double lat = GeoFormatter.parseLatOrLon(val);</span>
<span class="fc" id="L217">                double lon = GeoFormatter.parseLatOrLon(m.group(2));</span>

<span class="fc" id="L219">                parseResult.setLatitude(lat).setLongitude(lon);</span>
<span class="nc" id="L220">            } catch (ParseException e) {</span>
<span class="nc" id="L221">                e.printStackTrace();</span>
<span class="fc" id="L222">            }</span>
        }
<span class="fc" id="L224">    }</span>

    /** parsing helper: Get the first finding of pattern in whereToSearch if currentValue is not set yet.
     * Returns currentValue or content of first matching group of pattern. */
    private static String parseFindFromPattern(Pattern pattern, String currentValue, List&lt;String&gt; whereToSearch) {
<span class="pc bpc" id="L229" title="1 of 4 branches missed.">        if ((currentValue == null) || (currentValue.length() == 0)) {</span>
<span class="fc" id="L230">            Matcher m = parseFindWithPattern(pattern, whereToSearch);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">            String found = (m != null) ? m.group(1) : null;</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">            if (found != null) {</span>
<span class="fc" id="L233">                return found;</span>
            }
        }
<span class="fc" id="L236">        return currentValue;</span>
    }

    /** parsing helper: Get the first datetime finding in whereToSearch if currentValue is not set yet.
     * Returns currentValue or finding as Date . */
    private static Date parseTimeFromPattern(Date currentValue, String stringValue, List&lt;String&gt; whereToSearch) {
<span class="fc" id="L242">        String match = parseFindFromPattern(IsoDateTimeParser.ISO8601_FRACTIONAL_PATTERN, stringValue, whereToSearch);</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (match != null) {</span>
<span class="fc" id="L245">            return IsoDateTimeParser.parse(match);</span>
        }
<span class="fc" id="L247">        return currentValue;</span>
    }

    /** parsing helper: returns the match of the first finding of pattern in whereToSearch. */
    private static Matcher parseFindWithPattern(Pattern pattern, List&lt;String&gt; whereToSearch) {
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">        if (whereToSearch != null) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            for (String candidate : whereToSearch) {</span>
<span class="fc" id="L254">                Matcher m = parseFindWithPattern(pattern, candidate);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">                if (m != null) return m;</span>
<span class="fc" id="L256">            }</span>
        }
<span class="fc" id="L258">        return null;</span>
    }

    private static Matcher parseFindWithPattern(Pattern pattern, String candidate) {
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (candidate != null) {</span>
<span class="fc" id="L263">            Matcher m = pattern.matcher(candidate);</span>
<span class="pc bpc" id="L264" title="1 of 4 branches missed.">            while (m.find() &amp;&amp; (m.groupCount() &gt; 0)) {</span>
<span class="fc" id="L265">                return m;</span>
            }
        }
<span class="fc" id="L268">        return null;</span>
    }

    /** parsing helper: add a found query-parameter to a map for fast lookup */
    private void parseAddQueryParamToMap(HashMap&lt;String, String&gt; parmLookup, String param) {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">        if (param != null) {</span>
<span class="fc" id="L274">            String[] keyValue = param.split(&quot;=&quot;);</span>
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">            if ((keyValue != null) &amp;&amp; (keyValue.length == 2)) {</span>
                try {
<span class="fc" id="L277">                    parmLookup.put(keyValue[0], URLDecoder.decode(keyValue[1], DEFAULT_ENCODING));</span>
<span class="nc" id="L278">                } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L279">                    e.printStackTrace();</span>
<span class="fc" id="L280">                }</span>
            }
        }

<span class="fc" id="L284">    }</span>


    public String toUriString(double latitude, double longitude, int zoomLevel) {
<span class="nc" id="L288">        return toUriString(new GeoPointDto(latitude, longitude, zoomLevel));</span>
    }

    /**
     * Converts a {@link de.k3b.geo.api.IGeoPointInfo} into uri string representatino.&lt;br/&gt;
     * &lt;br/&gt;
     * Format
     *
     * geo:{lat{,lon{,hight_ignore}}}{?q={lat}{,lon}{,hight_ignore}{(name)}}{&amp;uri=uri}{&amp;id=id}{&amp;d=description}{&amp;z=zmin{&amp;z2=zmax}}{&amp;t=timeOfMeasurement}
     */
    public String toUriString(IGeoPointInfo geoPoint) {
<span class="fc" id="L299">        StringBuffer result = new StringBuffer();</span>
<span class="fc" id="L300">        result.append(GEO_SCHEME);</span>
<span class="fc" id="L301">        formatLatLon(result, geoPoint);</span>

<span class="fc" id="L303">        delim = &quot;?&quot;;</span>
<span class="fc" id="L304">        appendQueryParameter(result, GeoUriDef.QUERY, formatQuery(geoPoint), false);</span>
<span class="fc" id="L305">        appendQueryParameter(result, GeoUriDef.ZOOM, geoPoint.getZoomMin());</span>
<span class="fc" id="L306">        appendQueryParameter(result, GeoUriDef.ZOOM_MAX, geoPoint.getZoomMax());</span>
<span class="fc" id="L307">        appendQueryParameter(result, GeoUriDef.LINK, geoPoint.getLink(), true);</span>
<span class="fc" id="L308">        appendQueryParameter(result, GeoUriDef.SYMBOL, geoPoint.getSymbol(), true);</span>
<span class="fc" id="L309">        appendQueryParameter(result, GeoUriDef.DESCRIPTION, geoPoint.getDescription(), true);</span>
<span class="fc" id="L310">        appendQueryParameter(result, GeoUriDef.ID, geoPoint.getId(), true);</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (geoPoint.getTimeOfMeasurement() != null) {</span>
<span class="fc" id="L312">            appendQueryParameter(result, GeoUriDef.TIME, GeoFormatter.formatDate(geoPoint.getTimeOfMeasurement()), false);</span>
        }

<span class="fc" id="L315">        return result.toString();</span>
    }


    public String toUriString(IGeoPointInfo northEast, IGeoPointInfo southWest) {
<span class="fc" id="L320">        StringBuffer result = new StringBuffer();</span>
<span class="fc" id="L321">        result.append(AREA_SCHEME);</span>
<span class="fc" id="L322">        result.append(GeoFormatter.formatLatLon(northEast.getLatitude())).append(&quot;,&quot;);</span>
<span class="fc" id="L323">        result.append(GeoFormatter.formatLatLon(northEast.getLongitude())).append(&quot;,&quot;);</span>
<span class="fc" id="L324">        result.append(GeoFormatter.formatLatLon(southWest.getLatitude())).append(&quot;,&quot;);</span>
<span class="fc" id="L325">        result.append(GeoFormatter.formatLatLon(southWest.getLongitude()));</span>

<span class="fc" id="L327">        return result.toString();</span>
    }

    /** formatting helper: */
    private void appendQueryParameter(StringBuffer result, String paramName, int paramValue) {
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (paramValue != IGeoPointInfo.NO_ZOOM) {</span>
<span class="fc" id="L333">            appendQueryParameter(result, paramName, Integer.toString(paramValue), true);</span>
        }
<span class="fc" id="L335">    }</span>

    /** formatting helper: */
    private void appendQueryParameter(StringBuffer result, String paramName, String paramValue, boolean urlEncode) {
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (paramValue != null) {</span>
            try {
<span class="fc" id="L341">                result.append(delim).append(paramName).append(&quot;=&quot;);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                if (urlEncode) {</span>
<span class="fc" id="L343">                    paramValue = encode(paramValue);</span>
                }
<span class="fc" id="L345">                result.append(paramValue);</span>
<span class="fc" id="L346">                delim = &quot;&amp;&quot;;</span>
<span class="nc" id="L347">            } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L348">                e.printStackTrace();</span>
<span class="fc" id="L349">            }</span>
        }
<span class="fc" id="L351">    }</span>

    /** formatting helper: */
    private void formatLatLon(StringBuffer result, IGeoPointInfo geoPoint) {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (geoPoint != null) {</span>
<span class="fc" id="L356">            result.append(GeoFormatter.formatLatLon(geoPoint.getLatitude()));</span>

<span class="fc bfc" id="L358" title="All 2 branches covered.">            if (geoPoint.getLongitude() != IGeoPointInfo.NO_LAT_LON) {</span>
<span class="fc" id="L359">                result</span>
                        .append(&quot;,&quot;)
                        .append(GeoFormatter.formatLatLon(geoPoint.getLongitude()));
            }
        }
<span class="fc" id="L364">    }</span>

    /** formatting helper: */
    private String formatQuery(IGeoPointInfo geoPoint) {
        // {lat{,lon{,hight_ignore}}}{(name)}{|uri{|id}|}{description}
<span class="fc" id="L369">        StringBuffer result = new StringBuffer();</span>

<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (isSet(OPT_FORMAT_REDUNDANT_LAT_LON)) {</span>
<span class="fc" id="L372">            formatLatLon(result, geoPoint);</span>
        }

<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (geoPoint.getName() != null) {</span>
            try {
<span class="fc" id="L377">                result.append(&quot;(&quot;).append(encode(geoPoint.getName())).append(&quot;)&quot;);</span>
<span class="nc" id="L378">            } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L379">                e.printStackTrace();</span>
<span class="fc" id="L380">            }</span>
        }
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (result.length() == 0) return null;</span>

<span class="fc" id="L384">        return result.toString();</span>
    }

    /** formatting helper: */
    private String encode(String raw) throws UnsupportedEncodingException {
<span class="fc" id="L389">        return URLEncoder.encode(raw, DEFAULT_ENCODING);</span>
    }

    /** return true, if opt is set */
    private boolean isSet(int opt) {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        return ((options &amp; opt) != 0);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>